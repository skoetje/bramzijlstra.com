    ---
    title: "In a way, we've always been vibe coding (but also not at all)"
    date: 2025-03-12T13:04:06+01:00
    draft: false
    blueskyUrl: 'https://bsky.app/profile/bramzijlstra.com/post/3letwct3cg225'
    ---
    
    A little bit over 10 years ago, in 2014, I decided to learn how to program. Since I was interested in Artificial Intelligence and Data Science, I picked up Python.
    
    Being a Python developer was not without controversy back then. Python has some convenient advantages, which makes it an excellent beginner language. The syntax is straightforward, and for almost any problem you can think of there is a library you can use to solve it. These benefits come at a cost, would the previous generation
    of developers argue. They are often more versed in Java, and cringe at some of the concepts Python introduced. Sure, you can write Python code much faster. But at what cost?
    The lack of statically typing makes you write code faster, but you risk introducing bugs and your code will run much slower. And why importing so many dependencies? You have no idea what kind of code you are injecting!
    
    With this in mind, Java seems like the right language for people who want to have more control over their code at the cost of being slower in developing.
    But when Java became popular, *they* were the cool and careless crowd. With Java, you didn't
    need to program with pointers like in C. This made programming much easier, to the point where C fans would argue that Java is not real programming. Sure, you can write faster code,
    but Java made programming too easy. You have no idea what is really going on in your code.
    
    This trend continues for each generation you go back in time. Before C you had programmers using assembly, and even before that people used literal 0 and 1s in machine code.
    
    Each innovation in technology did exactly the same thing: we abstract away yesterday's work, so we can focus on tomorrow's problems. 
    This new ability comes at the cost of full control of the underlying abstraction. Whether this cost
    is in your budget, depends on what you want to do. 
    
    
    > „If you wish to make an apple pie from scratch, you must first invent the universe.“ - Carl Sagan
    
    As someone with a passion for cooking, most of my analogies come from food. The above quote of Sagan is 
    a good analogy for the trade-off that we have to make in abstraction versus speed. If you decide you want to eat pasta, you have a wide array of abstraction/speed combinations. At the one end, you can order a delivery service to bring Penne Carbonara from the menu. 
    Here you have 0 control over the end result, except for picking a restaurant with great reviews. Further down the abstraction path you can cook your own pasta dish, with the advantage that you can select the sauce you want. You could even decide to make your own sauce, and even your own pasta. Even further down the road, you can decide to grow your own vegetables. At this point, you will have to prepare months in advance that you want to eat a primavera sauce.
    
    When it comes to software development, the convenience is never convenient enough. Food delivery? Why can't I order pre-digested food and have it in my gut directly?
    
    Fast forwarding to 2025. It's clear that **vibe coding** is one of the hottest trends in software right now, and not just because of all the data centers that are burning because of it. And it got me  thinking: is vibe coding a natural progression of technology, or is it fundamentally different?
    
    On the surface I would say vibe coding is a perfect progression of previous technology. Vibe coding makes you incredibly fast, at the cost of an almost absolute lack of understanding. Over the last couple of months, I've been able to build *some* things 10 times faster than I would normally do.
    And yes, these rapid advancements came for the same price as every other invention: I had no idea how the code looked. I could read it, but why bother? I didn't know *why* it was written, and couldn't ask for a non-hallucinated response. The odds that the code would be refactored a few minutes later were too high for me to make reading it worthwhile.
    Even though attention was all that was needed, I never felt less attending at a codebase than before.
    
    > „It only takes one smart cow to open the latch of the gate, and then all the other cows follow.“
    
    But on the other hand I think vibe coding is a fundamental shift in technology, and that's because the underlying principles are not entirely the same. In previous technological advancements, part of the tradeoff was you lose flexibility for the benefit of having someone really smart taking care of the problem. This is called the [smart cow problem](https://en.wikipedia.org/wiki/Smart_cow_problem), 
    which states that a problem only needs to be solved once for entire generations to benefit from it. I have no idea how operating systems, assembly, and networking works, but I benefit from it every day. If I had to make my own operating system, I might have done things differently. But not having to do it saves me a tremendous amount of time.
    With vibe coding, I have all the flexibility in the world and none of the trust. It's what makes it very interesting, I feel like I have to use a completely different part of my brain. So far, the vibe highs are high and the vibe lows are low. I am amazed by how fast you can build something, but debugging has become even more frustrating. Is it because vibe coding makes you less patient? Probably. But I think it's also because we are trading agency with using agents.
    
    I am very curious to see where vibe coding will end, but it is safe to say it is one of the most interesting advancements in technology. For better and worse. Now excuse all you smart cows and universe inventors while I'll go eating apple pies.